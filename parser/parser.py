# parser.py - Parse C code using pycparser and generate 3-address code

import os
import sys
from pycparser import c_parser, c_ast, parse_file
import pycparser.c_generator

class TACGenerator(c_ast.NodeVisitor):
    """
    Node visitor that generates Three Address Code (TAC) from C code AST.
    """
    
    def __init__(self):
        """Initialize the TAC generator with empty lists for instructions and temp variables."""
        self.instructions = []  # List to store all TAC instructions
        self.temp_counter = 0   # Counter for generating temporary variables
        self.var_declarations = set()  # Track declared variables
        
    def new_temp(self):
        """Generate a new temporary variable name."""
        temp = f"t{self.temp_counter}"
        self.temp_counter += 1
        return temp
    
    def visit_Decl(self, node):
        """Process variable declarations."""
        if isinstance(node.type, c_ast.TypeDecl):
            # Track the variable as declared
            var_name = node.name
            self.var_declarations.add(var_name)
            
            # If there's an initialization value, process it
            if node.init:
                result = self.visit(node.init)
                self.instructions.append({
                    'type': 'assign',
                    'lhs': var_name,
                    'rhs': result
                })
                return var_name
            return var_name
        return None
        
    def visit_Assignment(self, node):
        """Process assignment statements."""
        # Visit the right side to get the value
        rhs = self.visit(node.rvalue)
        
        # Get the left side variable name
        lhs = node.lvalue.name if isinstance(node.lvalue, c_ast.ID) else self.visit(node.lvalue)
        
        # Create an assignment instruction
        self.instructions.append({
            'type': 'assign',
            'lhs': lhs,
            'rhs': rhs
        })
        
        return lhs
    
    def visit_BinaryOp(self, node):
        """Process binary operations like addition, subtraction, etc."""
        # Visit left and right operands
        left = self.visit(node.left)
        right = self.visit(node.right)
        
        # Create a new temporary variable
        result = self.new_temp()
        
        # Create a binary operation instruction
        self.instructions.append({
            'type': 'binop',
            'lhs': result,
            'op': node.op,
            'arg1': left,
            'arg2': right
        })
        
        return result
    
    def visit_ID(self, node):
        """Process variable references."""
        return node.name
    
    def visit_Constant(self, node):
        """Process constant values."""
        return node.value
    
    def visit_FuncDef(self, node):
        """Visit function definitions to process their bodies."""
        # Process the function body
        if node.body:
            self.visit(node.body)
    
    def visit_Compound(self, node):
        """Visit compound statements (blocks of code)."""
        if node.block_items:
            for stmt in node.block_items:
                self.visit(stmt)

def parse_c_file(filename):
    """
    Parse a C file and return the AST using pycparser's built-in
    preprocessor handling.
    
    Args:
        filename (str): Path to the C file to parse
        
    Returns:
        The AST generated by pycparser or None if there's an error
    """
    try:
        # Use pycparser's parse_file with cpp_args to handle preprocessor directives
        ast = parse_file(
            filename, 
            use_cpp=True,
            cpp_args=['-E', r'-Ipycparser/utils/fake_libc_include']
        )
        return ast
    except Exception as e:
        print(f"Error parsing file: {e}")
        return None

def generate_tac(ast):
    """
    Generate 3-address code from an AST.
    
    Args:
        ast: The AST generated by pycparser
        
    Returns:
        List of TAC instructions
    """
    if ast is None:
        return []
    
    # Create a TAC generator
    generator = TACGenerator()
    
    # Visit all nodes in the AST
    generator.visit(ast)
    
    return generator.instructions

def process_file(input_file):
    """
    Process a C file and generate 3-address code.
    
    Args:
        input_file (str): Path to the input C file
        
    Returns:
        List of TAC instructions
    """
    # Parse the file to get the AST
    ast = parse_c_file(input_file)
    
    if ast is None:
        print(f"Failed to parse {input_file}. Check the file for syntax errors.")
        return []
    
    # Generate TAC from the AST
    tac = generate_tac(ast)
    
    if not tac:
        print(f"Warning: No TAC instructions generated from {input_file}.")
    
    return tac

if __name__ == "__main__":
    # If this script is run directly, process the default input file
    default_input = "../input/sample.c"
    
    if len(sys.argv) > 1:
        input_file = sys.argv[1]
    else:
        input_file = default_input
    
    tac_instructions = process_file(input_file)
    
    # Print the TAC instructions
    for i, instr in enumerate(tac_instructions):
        print(f"{i}: {instr}")